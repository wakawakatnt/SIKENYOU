<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ONJ 掲示板データ検索</title>
<style>
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,Arial; margin: 18px; line-height: 1.5; background-color: #f4f4f9; color: #333; }
  input[type="text"] { padding: 10px; width: 70%; margin-right: 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 1em; }
  button { padding: 10px 18px; border: none; border-radius: 6px; background-color: #1976d2; color: white; cursor: pointer; font-size: 1em; }
  button:hover { background-color: #1565c0; }
  #clearBtn { background-color: #757575; }
  #clearBtn:hover { background-color: #616161; }
  #docsBtn { background-color: #4caf50; }
  #docsBtn:hover { background-color: #45a049; }
  #shareBtn { background-color: #ff9800; }
  #shareBtn:hover { background-color: #f57c00; }
  #refreshBtn { background-color: #f44336; }
  #refreshBtn:hover { background-color: #d32f2f; }
  #helpBtn { background-color: #9c27b0; }
  #helpBtn:hover { background-color: #7b1fa2; }
  .controls { margin-bottom: 20px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
  .info { background: #e3f2fd; padding: 12px; margin-bottom: 20px; border-radius: 6px; border-left: 5px solid #1976d2; }

  /* フェッチオプション */
  .fetch-options { background: #fff; border: 1px solid #ddd; padding: 12px; border-radius: 6px; margin-bottom: 20px; display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
  .fetch-options label { display: inline-flex; align-items: center; gap: 5px; cursor: pointer; }
  .fetch-options input[type="number"] { width: 65px; padding: 6px; border-radius: 4px; border: 1px solid #ccc; }

  /* 検索オプション */
  .search-options-wrapper { display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px; }
  .search-type-options, .sort-options { background: #fff; border: 1px solid #ddd; border-radius: 6px; padding: 12px; }
  .search-type-options label, .sort-options label { margin-right: 20px; display: inline-flex; align-items: center; gap: 5px; cursor: pointer; }
  .search-type-options input[type="radio"], .sort-options input[type="radio"] { margin-right: 5px; }
  .sort-options { display: none; } /* 初期状態は非表示 */

  /* ドキュメント一覧のスタイル */
  .documents-list { background: #fff; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 20px; display: none; }
  .documents-header { padding: 15px; background: #f5f5f5; border-bottom: 1px solid #ddd; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }
  .document-item { padding: 12px 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: background-color 0.2s; }
  .document-item:hover { background: #f9f9f9; }
  .document-item:last-child { border-bottom: none; }
  .document-name { font-weight: 500; color: #1976d2; }
  .document-info { display: flex; gap: 15px; font-size: 0.9em; color: #666; }
  .document-size { font-weight: bold; }
  .document-stats { font-size: 0.8em; }
  .active-document { background: #e8f5e8; }

  /* スレッド検索結果のスタイル */
  .thread-result { border: 1px solid #ddd; border-radius: 8px; margin-bottom: 12px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
  .thread-header { padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; gap: 15px; }
  .thread-header:hover { background: #f5f5f5; }
  .thread-title-wrapper { flex-grow: 1; min-width: 0; }
  .thread-title { font-weight: bold; color: #1976d2; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .thread-stats { text-align: right; flex-shrink: 0; }
  .total-posts { font-size: 0.85em; color: #666; display: block; }
  .match-count { font-size: 0.9em; color: #c0392b; font-weight: bold; }
  .document-source { font-size: 0.8em; color: #888; font-style: italic; }
  .last-updated { font-size: 0.8em; color: #666; margin-top: 2px; }
  
  .thread-details { display: none; padding: 0 15px 15px; border-top: 1px solid #eee; }
  .thread-meta { padding: 12px 0; font-size: 0.95em; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
  .thread-meta a { color: #007bff; text-decoration: none; }
  .thread-meta a:hover { text-decoration: underline; }
  
  /* レス取得ボタン */
  .post-control-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
  .post-control-buttons button { padding: 6px 12px; font-size: 0.85em; background-color: #28a745; }
  .post-control-buttons button:hover { background-color: #218838; }
  .post-control-buttons button.active { background-color: #ffc107; color: #212529; }
  .post-control-buttons button.active:hover { background-color: #e0a800; }
  
  /* 個別レスのボタン */
  .post-buttons { display: inline-flex; gap: 5px; margin-left: 10px; }
  .post-buttons button { padding: 3px 8px; font-size: 0.75em; background-color: #6c757d; }
  .post-buttons button:hover { background-color: #5a6268; }
  
  /* レスのスタイル */
  .post { border-top: 1px dashed #ccc; padding: 12px 0; position: relative; }
  .post:first-child { border-top: none; }
  .post-meta { font-size: 0.9em; color: #555; margin-bottom: 8px; }
  .post-meta strong { color: #008000; cursor: pointer; }
  .post-meta strong:hover { text-decoration: underline; }
  .post-content { white-space: pre-wrap; line-height: 1.6; background: #fafafa; padding: 10px; border-radius: 4px; word-wrap: break-word; }
  .highlight { background-color: #ffeb3b; padding: 1px 2px; border-radius: 2px; }
  
  /* 安価プレビュー */
  .anchor-link { color: #1976d2; text-decoration: underline; cursor: pointer; }
  .anchor-preview { position: absolute; background: #fff; border: 2px solid #1976d2; border-radius: 6px; padding: 10px; max-width: 400px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-size: 0.9em; }
  .anchor-preview .preview-meta { font-weight: bold; color: #008000; margin-bottom: 5px; }
  .anchor-preview .preview-content { white-space: pre-wrap; line-height: 1.4; }

  /* 検索結果サマリー */
  .search-summary { background: #fff3cd; border: 1px solid #ffeaa7; padding: 12px; border-radius: 6px; margin-bottom: 20px; }
  .search-summary strong { color: #856404; }

  /* ローディング表示 */
  .loading { text-align: center; padding: 40px; color: #666; }
  .loading::after { content: ''; display: inline-block; width: 20px; height: 20px; border: 2px solid #ddd; border-radius: 50%; border-top-color: #1976d2; animation: spin 1s ease-in-out infinite; margin-left: 10px; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* 説明パネル */
  .help-panel { background: #fff; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 20px; padding: 20px; display: none; }
  .help-panel h3 { color: #1976d2; margin-top: 0; }
  .help-panel h4 { color: #333; margin-top: 20px; margin-bottom: 10px; }
  .help-panel ul { margin-left: 20px; }
  .help-panel li { margin-bottom: 5px; }

  /* レスポンシブ対応 */
  @media (max-width: 768px) {
    .controls { flex-direction: column; align-items: stretch; }
    input[type="text"] { width: 100%; margin-right: 0; margin-bottom: 10px; box-sizing: border-box; }
    .document-item { flex-direction: column; align-items: flex-start; gap: 8px; }
    .document-info { flex-direction: column; gap: 5px; }
    .search-type-options label, .sort-options label { display: block; margin-bottom: 8px; }
  }
</style>
</head>
<body>
<h2>ONJ 掲示板データ検索システム</h2>

<div class="controls">
  <input type="text" id="searchInput" placeholder="検索ワード（名前、ID、投稿内容）">
  <button id="searchBtn">検索</button>
  <button id="clearBtn">クリア</button>
  <button id="docsBtn">ドキュメント一覧</button>
  <button id="shareBtn">URL共有</button>
  <button id="helpBtn">説明</button>
</div>

<div class="fetch-options">
  <strong>検索対象:</strong>
  <label>
    最新 <input type="number" id="fetchCount" value="15" min="1"> 件
  </label>
  <label>
    <input type="checkbox" id="fetchAllDocs"> 全て取得
  </label>
  <button id="refreshBtn" title="キャッシュをクリアして再取得・再検索します">リフレッシュ</button>
</div>

<div class="search-options-wrapper">
  <div id="searchTypeOptions" class="search-type-options">
    <strong>検索範囲:</strong>
    <label>
      <input type="radio" name="searchType" value="all" checked> 全て
    </label>
    <label>
      <input type="radio" name="searchType" value="title"> スレタイのみ
    </label>
    <label>
      <input type="radio" name="searchType" value="body"> 本文のみ (名前, ID, 投稿内容)
    </label>
  </div>

  <div id="sortOptions" class="sort-options">
    <strong>結果の並び順:</strong>
    <label>
      <input type="radio" name="sortOrder" value="newest" checked> 最新順
    </label>
    <label>
      <input type="radio" name="sortOrder" value="oldest"> 古い順
    </label>
    <label>
      <input type="radio" name="sortOrder" value="document"> ドキュメント名順
    </label>
    <label>
      <input type="radio" name="sortOrder" value="relevance"> 関連度順
    </label>
  </div>
</div>

<div id="helpPanel" class="help-panel">
  <h3>ONJ掲示板データ検索システム - 使い方ガイド</h3>
  
  <h4>概要</h4>
  <p>このシステムはONJ（おんJつまりなんでも実況Jupiter）掲示板のスレッドデータを検索・閲覧できるツールです。スレッドタイトル、投稿者名、ID、投稿内容を対象に検索できます。</p>
  
  <h4>基本的な使い方</h4>
  <ul>
    <li><strong>検索:</strong> 検索ボックスにキーワードを入力して「検索」ボタンを押すか、Enterキーを押してください</li>
    <li><strong>ID検索:</strong> 「id:○○○○」の形式で入力すると、特定のIDで投稿されたレスを検索できます</li>
    <li><strong>検索範囲:</strong> 「全て」「スレタイのみ」「本文のみ」から選択できます</li>
    <li><strong>並び順:</strong> 「最新順」「古い順」「ドキュメント名順」「関連度順」から選択できます</li>
    <li><strong>高度な検索:</strong> 「/!()」で始まる特殊な構文を使用して、より複雑な検索が可能です</li>
  </ul>
  
  <h4>検索対象の設定</h4>
  <ul>
    <li><strong>最新○件:</strong> 最新のドキュメントから指定した件数を検索対象にします</li>
    <li><strong>全て取得:</strong> チェックすると、利用可能な全てのドキュメントを検索対象にします</li>
    <li><strong>リフレッシュ:</strong> キャッシュをクリアして最新データを取得し直します</li>
  </ul>
  
  <h4>検索結果の操作</h4>
  <ul>
    <li><strong>スレッド展開:</strong> スレッドタイトルをクリックすると、マッチした投稿が表示されます</li>
    <li><strong>全レス表示:</strong> 「全レス表示」ボタンでスレッド内の全ての投稿を表示できます</li>
    <li><strong>上100レス/下100レス:</strong> 各投稿の前後100レスを表示できます（上は-100〜-1、下は+1〜+100）</li>
    <li><strong>安価プレビュー:</strong> 「>>○○」にマウスを乗せると、該当する投稿をプレビュー表示します</li>
    <li><strong>安価クリック:</strong> 「>>○○」をクリックすると、該当する投稿を表示します</li>
    <li><strong>レス番号クリック:</strong> レス番号をクリックすると、元スレッドの該当レスへジャンプします</li>
  </ul>
  
  <h4>その他の機能</h4>
  <ul>
    <li><strong>URL共有:</strong> 検索結果のURLをコピーして他の人と共有できます</li>
    <li><strong>ドキュメント一覧:</strong> 利用可能なドキュメントの詳細情報を確認できます</li>
    <li><strong>スレッドリンク:</strong> 元の掲示板スレッドへのリンクも表示されます</li>
  </ul>
</div>

<div id="documentsList" class="documents-list">
  <div class="documents-header">
    <span>利用可能なドキュメント一覧</span>
    <span id="documentsCount"></span>
  </div>
  <div id="documentsContent"></div>
</div>

<div id="info" class="info">ここにデータ情報や検索結果が表示されます。</div>
<div id="searchSummary" class="search-summary" style="display: none;"></div>
<div id="results"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, getDoc } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
  
  const firebaseConfig = {
    apiKey: "AIzaSyA2Z-JByRuaSv88nAj356nOh4CNgQb0_SY",
    authDomain: "onj-zenbun-kensaku.firebaseapp.com",
    projectId: "onj-zenbun-kensaku",
    storageBucket: "onj-zenbun-kensaku.firebasestorage.app",
    messagingSenderId: "171332002735",
    appId: "1:171332002735:web:c8dcad3ae133300900855a",
    measurementId: "G-DDHGB57HTW"
  };
  
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  let allDocuments = [];
  let allDocumentThreads = new Map(); // ドキュメントID -> スレッドデータのマップ
  let currentSearchResults = []; // 現在の検索結果を保存
  let totalDocumentCount = 0; // メタから取得する総ドキュメント数
  let fetchedDocumentIds = new Set(); // 取得済みのドキュメントIDを追跡

  function formatBytes(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  function parseDateTime(dateTimeStr) {
    if (!dateTimeStr) return null;
    const match = dateTimeStr.match(/(\d{2})\/(\d{2})\/(\d{2})\([^)]+\)\s+(\d{2}):(\d{2}):(\d{2})/);
    if (!match) return null;
    const [, year, month, day, hour, minute, second] = match;
    const fullYear = parseInt(year) + 2000;
    return new Date(fullYear, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second));
  }
  
  function parseContentData(content) {
    const threads = [];
    // スレッドIDで分割
    const threadParts = content.split(/=!=!=(\d+)=!=!=/);
    if (threadParts[0] === '') threadParts.shift();
    
    for (let i = 0; i < threadParts.length; i += 2) {
      const threadId = threadParts[i];
      const threadContent = threadParts[i + 1];
      if (!threadId || !threadContent) continue;
      
      // スレッドの最終更新時刻を取得
      const contentParts = threadContent.split('=?=?=');
      let cleanThreadContent = (contentParts.length >= 3) ? contentParts.slice(2).join('=?=?=').trim() : threadContent.trim();
      if (!cleanThreadContent) continue;
      
      // 行で分割
      const lines = cleanThreadContent.split('\n');
      let posts = [];
      let threadTitle = "（タイトル不明）";
      let lastPostTime = null;
      let postNumber = 0;

      for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
        const line = lines[lineIndex].trim();
        if (!line) continue;

        // レスの開始条件をより厳密に判定
        // 1. 「名無しさん＠おーぷん<>」で始まる場合
        // 2. または「名無し」で始まり「<>」を含む場合
        const isPostStart = line.startsWith('名無しさん＠おーぷん<>') || 
                           (line.startsWith('名無し') && line.includes('<>') && line.includes('ID:'));

        if (isPostStart) {
          postNumber++;
          const parts = line.split('<>');
          if (parts.length < 3) continue;

          const author = parts[0].trim();
          let emailOrSage = '';
          let dateTimeAndId = '';
          let postBodyContent = '';
          
          // パターン判定: 名前<>sage<>日時 ID<>内容 または 名前<><>日時 ID<>内容
          if (parts.length >= 4 && parts[2].match(/\d{2}\/\d{2}\/\d{2}/)) {
            emailOrSage = parts[1] || '';
            dateTimeAndId = parts[2];
            postBodyContent = parts.slice(3).join('<>');
          } else if (parts.length >= 3 && parts[1].match(/\d{2}\/\d{2}\/\d{2}/)) {
            dateTimeAndId = parts[1];
            postBodyContent = parts.slice(2).join('<>');
          } else {
            // 日時がない場合の処理（IDのみのパターン）
            for (let j = 1; j < parts.length; j++) {
              if (parts[j].includes('ID:')) {
                dateTimeAndId = parts[j];
                postBodyContent = parts.slice(j + 1).join('<>');
                break;
              }
            }
          }

          // 日時とIDを分離
          let postTime = '';
          let userId = '';
          
          if (dateTimeAndId.includes('ID:')) {
            const dateIdMatch = dateTimeAndId.match(/^(.+?)\s+ID:\s*(\S+)$/);
            if (dateIdMatch) {
              [, postTime, userId] = dateIdMatch;
            } else {
              // ID:のみの場合
              const idMatch = dateTimeAndId.match(/ID:\s*(\S+)/);
              if (idMatch) {
                userId = idMatch[1];
                postTime = '不明';
              }
            }
          }

          const parsedTime = parseDateTime(postTime);
          if (parsedTime) lastPostTime = parsedTime;

          // 1レス目の場合、スレッドタイトルを抽出
          if (postNumber === 1 && postBodyContent) {
            const bodyParts = postBodyContent.split('<>');
            let titleCandidate = '';
            
            // 最後の有効なパートを探す（URLやIDを除く）
            for (let j = bodyParts.length - 1; j >= 0; j--) {
              const part = bodyParts[j].trim();
              if (part && part.length >= 3 && 
                  !part.startsWith('http') && 
                  !part.includes('ID:') && 
                  !part.match(/^\d+$/)) {
                titleCandidate = part;
                break;
              }
            }
            
            if (titleCandidate) {
              threadTitle = titleCandidate;
              // タイトル部分を除いた内容を投稿内容とする
              const titleIndex = postBodyContent.lastIndexOf('<>' + titleCandidate);
              if (titleIndex !== -1) {
                postBodyContent = postBodyContent.substring(0, titleIndex).replace(/<>$/, '').trim();
              }
            }
          }
          
          posts.push({
            postNumber: postNumber,
            author: author,
            sage: emailOrSage === 'sage',
            postTime: postTime || '不明',
            postTimeDate: parsedTime,
            userId: userId || '不明',
            content: postBodyContent.replace(/<br>/g, '\n').trim()
          });
        }
      }
      
      if (posts.length > 0) {
        threads.push({
          id: threadId,
          title: threadTitle,
          link: `https://hayabusa.open2ch.net/test/read.cgi/livejupiter/${threadId}/`,
          posts: posts,
          lastUpdated: posts[posts.length - 1].postTime,
          lastUpdatedDate: lastPostTime
        });
      }
    }
    return threads;
  }
  
  async function initializeSystem() {
    const infoDiv = document.getElementById('info');
    try {
      infoDiv.innerHTML = '<div class="loading">システムを初期化中...</div>';
      const metaDocRef = doc(db, "meta", "document_count");
      const metaDocSnap = await getDoc(metaDocRef);

      if (metaDocSnap.exists()) {
        totalDocumentCount = metaDocSnap.data().totalDocuments;
        const fetchCountInput = document.getElementById('fetchCount');
        fetchCountInput.max = totalDocumentCount;
        if (parseInt(fetchCountInput.value, 10) > totalDocumentCount) {
            fetchCountInput.value = totalDocumentCount;
        }
        infoDiv.innerHTML = `準備完了。全${totalDocumentCount}件のドキュメントから検索できます。`;
      } else {
        totalDocumentCount = 0;
        infoDiv.textContent = 'エラー: ドキュメント数のメタデータが見つかりません。';
      }
    } catch (err) {
      infoDiv.textContent = `初期化エラー: ${err.message}`;
      console.error(err);
    }
    checkUrlParams();
  }

  async function fetchRequiredDocuments() {
    const fetchAll = document.getElementById('fetchAllDocs').checked;
    const fetchCountInput = document.getElementById('fetchCount');
    let numToFetch = parseInt(fetchCountInput.value, 10);

    if (isNaN(numToFetch) || numToFetch <= 0) {
      numToFetch = 1;
      fetchCountInput.value = '1';
    }

    const docIdsToRequest = new Set();
    if (fetchAll) {
      for (let i = 1; i <= totalDocumentCount; i++) docIdsToRequest.add(String(i));
    } else {
      const startId = totalDocumentCount;
      const endId = Math.max(1, totalDocumentCount - numToFetch + 1);
      for (let i = startId; i >= endId; i--) docIdsToRequest.add(String(i));
    }

    const newDocIdsToFetch = [...docIdsToRequest].filter(id => !fetchedDocumentIds.has(id));
    if (newDocIdsToFetch.length === 0) {
      updateInfoPanel();
      return true;
    }

    const infoDiv = document.getElementById('info');
    infoDiv.innerHTML = `<div class="loading">${newDocIdsToFetch.length}件の新規ドキュメントを読み込み中...</div>`;

    try {
      const fetchPromises = newDocIdsToFetch.map(id => getDoc(doc(db, "aggregated_threads", id)));
      const docSnapshots = await Promise.all(fetchPromises);

      for (const docSnapshot of docSnapshots) {
        if (docSnapshot.exists()) {
          const docId = docSnapshot.id;
          const data = docSnapshot.data();
          const threads = parseContentData(data.content || '');
          allDocumentThreads.set(docId, threads);
          
          if (!allDocuments.some(d => d.id === docId)) {
            const contentSize = data.content ? new Blob([data.content]).size : 0;
            const lastUpdated = data.lastUpdated ? new Date(data.lastUpdated.seconds * 1000).toLocaleString('ja-JP') : '不明';
            const threadCount = threads.length;
            const postCount = threads.reduce((sum, t) => sum + t.posts.length, 0);
            allDocuments.push({
              id: docId, name: docId, size: contentSize, lastUpdated: lastUpdated,
              threadCount: threadCount, postCount: postCount, data: data
            });
          }
          fetchedDocumentIds.add(docId);
        }
      }
      
      allDocuments.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
      renderDocumentsList();
      updateInfoPanel();
      return true;
    } catch (err) {
      infoDiv.textContent = `ドキュメントの読み込みエラー: ${err.message}`;
      console.error(err);
      return false;
    }
  }

  function renderDocumentsList() {
    const documentsContent = document.getElementById('documentsContent');
    const documentsCount = document.getElementById('documentsCount');
    
    documentsCount.textContent = `${allDocuments.length}件のドキュメント (読み込み済み)`;
    documentsContent.innerHTML = '';
    
    allDocuments.forEach(doc => {
      const docDiv = document.createElement('div');
      docDiv.className = 'document-item';
      docDiv.innerHTML = `
        <div class="document-name">${doc.name}</div>
        <div class="document-info">
          <span class="document-size">${formatBytes(doc.size)}</span>
          <span class="document-stats">スレッド: ${doc.threadCount}件, 投稿: ${doc.postCount}件</span>
          <span>更新: ${doc.lastUpdated}</span>
        </div>
      `;
      documentsContent.appendChild(docDiv);
    });
  }

  function toggleDocumentsList() {
    const docsList = document.getElementById('documentsList');
    docsList.style.display = (docsList.style.display === 'none' || docsList.style.display === '') ? 'block' : 'none';
  }

  function toggleHelpPanel() {
    const helpPanel = document.getElementById('helpPanel');
    helpPanel.style.display = (helpPanel.style.display === 'none' || helpPanel.style.display === '') ? 'block' : 'none';
  }

  function updateInfoPanel() {
    if (allDocumentThreads.size > 0) {
        const totalThreads = Array.from(allDocumentThreads.values()).reduce((sum, threads) => sum + threads.length, 0);
        const totalPosts = Array.from(allDocumentThreads.values()).reduce((sum, threads) => sum + threads.reduce((s, t) => s + t.posts.length, 0), 0);
        document.getElementById('info').innerHTML = `
          <strong>検索対象:</strong> ${allDocumentThreads.size}件のドキュメントを読み込み済み | 
          <strong>総スレッド数:</strong> ${totalThreads} | 
          <strong>総投稿数:</strong> ${totalPosts}
        `;
    } else {
        document.getElementById('info').innerHTML = `準備完了。全${totalDocumentCount}件のドキュメントから検索できます。`;
    }
  }

  function highlightSearchTerm(text, term) {
    if (!term || !text) return text;
    let termToHighlight = term;
    const idSearchMatch = term.match(/^id:\s*(.*)/i);
    if (idSearchMatch) termToHighlight = idSearchMatch[1].trim().replace(/\s/g, '');
    if (!termToHighlight) return text;
    const escapedTerm = termToHighlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedTerm})`, 'gi');
    return text.replace(regex, '<span class="highlight">$1</span>');
  }

  function processAnchors(content, thread) {
    return content.replace(/>>\d+/g, (match) => {
      const postNum = match.substring(2);
      return `<span class="anchor-link" data-post-num="${postNum}" data-thread-id="${thread.id}">${match}</span>`;
    });
  }

  function createAnchorPreview(postNum, threadId) {
    const threads = Array.from(allDocumentThreads.values()).flat();
    const thread = threads.find(t => t.id === threadId);
    if (!thread) return null;

    const targetPost = thread.posts.find(p => p.postNumber === parseInt(postNum));
    if (!targetPost) return null;

    const previewDiv = document.createElement('div');
    previewDiv.className = 'anchor-preview';
    const cleanContent = targetPost.content.replace(/ <>$/, '').trim();
    previewDiv.innerHTML = `
      <div class="preview-meta">${targetPost.postNumber}: ${targetPost.author} | ${targetPost.postTime} | ID:${targetPost.userId}</div>
      <div class="preview-content">${cleanContent.substring(0, 200)}${cleanContent.length > 200 ? '...' : ''}</div>
    `;
    return previewDiv;
  }

  // 安価先のレスを表示する関数
  function showAnchorPost(postNum, threadId) {
    const threads = Array.from(allDocumentThreads.values()).flat();
    const thread = threads.find(t => t.id === threadId);
    if (!thread) return;

    const targetPost = thread.posts.find(p => p.postNumber === parseInt(postNum));
    if (!targetPost) return;

    // 該当スレッドの要素を探す
    const threadElements = document.querySelectorAll('.thread-result');
    let targetThreadElement = null;
    
    threadElements.forEach(element => {
      const threadTitle = element.querySelector('.thread-title');
      if (threadTitle && threadTitle.textContent.includes(thread.title)) {
        targetThreadElement = element;
      }
    });

    if (targetThreadElement) {
      // スレッドの詳細を展開
      const detailsDiv = targetThreadElement.querySelector('.thread-details');
      detailsDiv.style.display = 'block';
      
      // 既存のレスがあるか確認
      const existingPosts = detailsDiv.querySelectorAll('.post');
      let targetPostElement = null;
      
      existingPosts.forEach(postElement => {
        const postMeta = postElement.querySelector('.post-meta strong');
        if (postMeta && postMeta.textContent.startsWith(postNum + ':')) {
          targetPostElement = postElement;
        }
      });

      // レスが表示されていない場合は追加
      if (!targetPostElement) {
        const postDiv = document.createElement('div');
        postDiv.className = 'post';
        const cleanContent = targetPost.content.replace(/ <>$/, '').trim();
        const postContent = processAnchors(cleanContent, thread);
        const sageIndicator = targetPost.sage ? ' <span style="color: #888; font-size: 0.9em;">[sage]</span>' : '';
        
        postDiv.innerHTML = `
          <div class="post-meta">
            <strong data-thread-id="${thread.id}" data-post-num="${targetPost.postNumber}">${targetPost.postNumber}: ${targetPost.author}</strong>${sageIndicator} | 時刻: ${targetPost.postTime} | ID:${targetPost.userId}
            <div class="post-buttons">
              <button class="range-up" data-post-num="${targetPost.postNumber}">上100レス</button>
              <button class="range-down" data-post-num="${targetPost.postNumber}">下100レス</button>
            </div>
          </div>
          <div class="post-content">${postContent}</div>
        `;
        
        detailsDiv.appendChild(postDiv);
        targetPostElement = postDiv;
        
        // イベントリスナーを追加
        addPostEventListeners(postDiv, thread);
      }

      // スクロールして表示
      targetPostElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      targetPostElement.style.backgroundColor = '#ffffcc';
      setTimeout(() => {
        targetPostElement.style.backgroundColor = '';
      }, 2000);
    }
  }

  function sortSearchResults(results, sortOrder) {
    const sortedResults = [...results];
    switch (sortOrder) {
      case 'newest':
        sortedResults.sort((a, b) => (b.lastUpdatedDate || 0) - (a.lastUpdatedDate || 0));
        break;
      case 'oldest':
        sortedResults.sort((a, b) => (a.lastUpdatedDate || 0) - (b.lastUpdatedDate || 0));
        break;
      case 'document':
        sortedResults.sort((a, b) => (a.documentName || '').localeCompare(b.documentName || '', undefined, {numeric: true}));
        break;
      case 'relevance':
        sortedResults.sort((a, b) => b.matchedPosts.length - a.matchedPosts.length);
        break;
    }
    return sortedResults;
  }

  // レス範囲表示機能
  function showPostsInRange(thread, postElement, direction, keyword, button) {
    const postNumber = parseInt(postElement.querySelector('.post-meta strong').textContent.split(':')[0]);
    let startIndex, endIndex;
    
    if (direction === 'up') {
      // 上100レス: レス番号-100から-1まで
      startIndex = Math.max(0, postNumber - 100 - 1);
      endIndex = Math.max(0, postNumber - 1);
    } else {
      // 下100レス: レス番号+1から+100まで  
      startIndex = Math.min(thread.posts.length - 1, postNumber);
      endIndex = Math.min(thread.posts.length, postNumber + 100);
    }
    
    const postsToShow = thread.posts.slice(startIndex, endIndex);
    const container = document.createElement('div');
    container.className = `range-posts range-posts-${direction}`;
    
    postsToShow.forEach(post => {
      const postDiv = document.createElement('div');
      postDiv.className = 'post';
      
      const cleanContent = post.content.replace(/ <>$/, '').trim();
      const postContent = processAnchors(cleanContent, thread);
      const highlightedContent = (cleanContent.toLowerCase().includes(keyword.toLowerCase()) || 
                        post.author.toLowerCase().includes(keyword.toLowerCase()) || 
                        post.userId.toLowerCase().includes(keyword.toLowerCase().replace(/\s/g, '')))
        ? highlightSearchTerm(postContent, keyword) : postContent;
      const highlightedAuthor = highlightSearchTerm(post.author, keyword);
      const highlightedUserId = highlightSearchTerm(post.userId, keyword);
      const sageIndicator = post.sage ? ' <span style="color: #888; font-size: 0.9em;">[sage]</span>' : '';
      
      postDiv.innerHTML = `
        <div class="post-meta"><strong data-thread-id="${thread.id}" data-post-num="${post.postNumber}">${post.postNumber}: ${highlightedAuthor}</strong>${sageIndicator} | 時刻: ${post.postTime} | ID:${highlightedUserId}</div>
        <div class="post-content">${highlightedContent}</div>
      `;
      container.appendChild(postDiv);
      
      // レス番号クリックイベントを追加
      const postNumElement = postDiv.querySelector('.post-meta strong');
      postNumElement.addEventListener('click', (e) => {
        e.stopPropagation();
        const postNum = postNumElement.getAttribute('data-post-num');
        const threadId = postNumElement.getAttribute('data-thread-id');
        window.open(`https://hayabusa.open2ch.net/test/read.cgi/livejupiter/${threadId}/${postNum}-`, '_blank');
      });
    });

    if (direction === 'up') {
      postElement.parentNode.insertBefore(container, postElement);
    } else {
      postElement.parentNode.insertBefore(container, postElement.nextSibling);
    }

    // 安価プレビューイベントを追加
    addAnchorPreviewEvents(container);
  }

  function showAllPosts(thread, keyword, threadDiv) {
    const detailsDiv = threadDiv.querySelector('.thread-details');
    
    // 既存の範囲表示をすべて削除
    const rangeElements = detailsDiv.querySelectorAll('.range-posts');
    rangeElements.forEach(el => el.remove());
    
    // 既存のマッチしたレスをすべて削除
    const existingPosts = detailsDiv.querySelectorAll('.post');
    existingPosts.forEach(post => post.remove());
    
    const postsContainer = detailsDiv.querySelector('.posts-container') || (() => {
      const container = document.createElement('div');
      container.className = 'posts-container';
      detailsDiv.appendChild(container);
      return container;
    })();
    
    postsContainer.innerHTML = '';
    
    thread.posts.forEach(post => {
      const postDiv = document.createElement('div');
      postDiv.className = 'post';
      
      const cleanContent = post.content.replace(/ <>$/, '').trim();
      const postContent = processAnchors(cleanContent, thread);
      const highlightedContent = (cleanContent.toLowerCase().includes(keyword.toLowerCase()) || 
                        post.author.toLowerCase().includes(keyword.toLowerCase()) || 
                        post.userId.toLowerCase().includes(keyword.toLowerCase().replace(/\s/g, '')))
        ? highlightSearchTerm(postContent, keyword) : postContent;
      const highlightedAuthor = highlightSearchTerm(post.author, keyword);
      const highlightedUserId = highlightSearchTerm(post.userId, keyword);
      const sageIndicator = post.sage ? ' <span style="color: #888; font-size: 0.9em;">[sage]</span>' : '';
      
      postDiv.innerHTML = `
        <div class="post-meta"><strong data-thread-id="${thread.id}" data-post-num="${post.postNumber}">${post.postNumber}: ${highlightedAuthor}</strong>${sageIndicator} | 時刻: ${post.postTime} | ID:${highlightedUserId}</div>
        <div class="post-content">${highlightedContent}</div>
      `;
      postsContainer.appendChild(postDiv);
      
      // レス番号クリックイベントを追加
      const postNumElement = postDiv.querySelector('.post-meta strong');
      postNumElement.addEventListener('click', (e) => {
        e.stopPropagation();
        const postNum = postNumElement.getAttribute('data-post-num');
        const threadId = postNumElement.getAttribute('data-thread-id');
        window.open(`https://hayabusa.open2ch.net/test/read.cgi/livejupiter/${threadId}/${postNum}-`, '_blank');
      });
    });

    // 安価プレビューイベントを追加
    addAnchorPreviewEvents(postsContainer);
  }

  function addPostEventListeners(postDiv, thread) {
    // 上100レス・下100レスボタンのイベントリスナー
    const upButton = postDiv.querySelector('.range-up');
    const downButton = postDiv.querySelector('.range-down');
    const keyword = document.getElementById('searchInput').value.trim();
    
    if (upButton) {
      upButton.addEventListener('click', (e) => {
        e.stopPropagation();
        showPostsInRange(thread, postDiv, 'up', keyword, upButton);
      });
    }
    
    if (downButton) {
      downButton.addEventListener('click', (e) => {
        e.stopPropagation();
        showPostsInRange(thread, postDiv, 'down', keyword, downButton);
      });
    }
    
    // レス番号クリックイベントを追加
    const postNumElement = postDiv.querySelector('.post-meta strong');
    if (postNumElement) {
      postNumElement.addEventListener('click', (e) => {
        e.stopPropagation();
        const postNum = postNumElement.getAttribute('data-post-num');
        const threadId = postNumElement.getAttribute('data-thread-id');
        window.open(`https://hayabusa.open2ch.net/test/read.cgi/livejupiter/${threadId}/${postNum}-`, '_blank');
      });
    }
  }

  function addAnchorPreviewEvents(container) {
    const anchorLinks = container.querySelectorAll('.anchor-link');
    anchorLinks.forEach(link => {
      let previewElement = null;
      
      link.addEventListener('mouseenter', (e) => {
        const postNum = e.target.getAttribute('data-post-num');
        const threadId = e.target.getAttribute('data-thread-id');
        previewElement = createAnchorPreview(postNum, threadId);
        
        if (previewElement) {
          document.body.appendChild(previewElement);
          const rect = e.target.getBoundingClientRect();
          previewElement.style.left = Math.min(rect.left, window.innerWidth - previewElement.offsetWidth - 10) + 'px';
          previewElement.style.top = (rect.bottom + 5) + 'px';
        }
      });
      
      link.addEventListener('mouseleave', () => {
        if (previewElement) {
          document.body.removeChild(previewElement);
          previewElement = null;
        }
      });
      
      // 安価クリックイベントを追加
      link.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const postNum = e.target.getAttribute('data-post-num');
        const threadId = e.target.getAttribute('data-thread-id');
        showAnchorPost(postNum, threadId);
      });
    });
  }

  function renderSearchResults(results, keyword) {
    const resultsDiv = document.getElementById('results');
    const summaryDiv = document.getElementById('searchSummary');
    const sortOptionsDiv = document.getElementById('sortOptions');
    
    resultsDiv.innerHTML = '';

    if (results.length === 0) {
        resultsDiv.innerHTML = '<p>検索条件に一致するスレッドがありませんでした。</p>';
        summaryDiv.style.display = 'none';
        sortOptionsDiv.style.display = 'none';
        return;
    }

    sortOptionsDiv.style.display = 'block';
    const totalMatches = results.reduce((sum, r) => sum + r.matchedPosts.length, 0);
    summaryDiv.innerHTML = `
      <strong>検索結果:</strong> "${keyword}" | 
      <strong>対象:</strong> ${fetchedDocumentIds.size}ドキュメント | 
      <strong>ヒット:</strong> ${results.length}スレッド, ${totalMatches}投稿
    `;
    summaryDiv.style.display = 'block';

    results.forEach(thread => {
        const threadDiv = document.createElement('div');
        threadDiv.className = 'thread-result';
        const headerDiv = document.createElement('div');
        headerDiv.className = 'thread-header';
        headerDiv.innerHTML = `
            <div class="thread-title-wrapper">
                <span class="thread-title">${highlightSearchTerm(thread.title, keyword)}</span>
                ${thread.documentName ? `<div class="document-source">出典: ${thread.documentName}</div>` : ''}
                <div class="last-updated">最終更新: ${thread.lastUpdated}</div>
            </div>
            <div class="thread-stats">
                <span class="total-posts">全${thread.posts.length}レス</span>
                <span class="match-count">${thread.matchedPosts.length}件ヒット</span>
            </div>
        `;
        
        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'thread-details';
        detailsDiv.innerHTML = `
          <div class="thread-meta">
            <a href="${thread.link}" target="_blank" rel="noopener noreferrer">このスレッドへのリンク</a>
            <button class="show-all-posts" data-thread-id="${thread.id}">全レス表示</button>
          </div>
        `;

        // 全レス表示ボタンのイベントリスナー
        const showAllButton = detailsDiv.querySelector('.show-all-posts');
        showAllButton.addEventListener('click', (e) => {
          e.stopPropagation();
          showAllPosts(thread, keyword, threadDiv);
          showAllButton.style.display = 'none';
        });

        // 初期表示：マッチしたレスのみ表示
        thread.matchedPosts.forEach(post => {
            const postDiv = document.createElement('div');
            postDiv.className = 'post';
            
            const cleanContent = post.content.replace(/ <>$/, '').trim();
            const postContent = processAnchors(cleanContent, thread);
            const highlightedContent = (cleanContent.toLowerCase().includes(keyword.toLowerCase()) || 
                          post.author.toLowerCase().includes(keyword.toLowerCase()) || 
                          post.userId.toLowerCase().includes(keyword.toLowerCase().replace(/\s/g, '')))
              ? highlightSearchTerm(postContent, keyword) : postContent;
            const highlightedAuthor = highlightSearchTerm(post.author, keyword);
            const highlightedUserId = highlightSearchTerm(post.userId, keyword);
            const sageIndicator = post.sage ? ' <span style="color: #888; font-size: 0.9em;">[sage]</span>' : '';
            
            postDiv.innerHTML = `
                <div class="post-meta">
                  <strong data-thread-id="${thread.id}" data-post-num="${post.postNumber}">${post.postNumber}: ${highlightedAuthor}</strong>${sageIndicator} | 時刻: ${post.postTime} | ID:${highlightedUserId}
                  <div class="post-buttons">
                    <button class="range-up" data-post-num="${post.postNumber}">上100レス</button>
                    <button class="range-down" data-post-num="${post.postNumber}">下100レス</button>
                  </div>
                </div>
                <div class="post-content">${highlightedContent}</div>
            `;
            
            // イベントリスナーを追加
            addPostEventListeners(postDiv, thread);
            
            detailsDiv.appendChild(postDiv);
        });

        // 安価プレビューイベントを追加
        addAnchorPreviewEvents(detailsDiv);

        headerDiv.addEventListener('click', () => { 
          detailsDiv.style.display = (detailsDiv.style.display === 'none' || detailsDiv.style.display === '') ? 'block' : 'none'; 
        });
        threadDiv.appendChild(headerDiv);
        threadDiv.appendChild(detailsDiv);
        resultsDiv.appendChild(threadDiv);
    });
  }

  // 高度な検索を解析する関数
  function parseAdvancedSearch(query) {
    if (!query.startsWith('/!()')) return null;
    
    const searchBody = query.substring(4);
    const result = {
      type: 'advanced',
      conditions: [],
      all: false,
      documentRange: null,
      searchMode: 'partial', // デフォルトを部分一致に
      expression: null,
      ifageTerms: [],
      ifsageTerms: []
    };

    // <all>の場合
    if (searchBody.match(/^{<all>}/)) {
      result.all = true;
      return result;
    }

    let processedBody = searchBody;

    // ドキュメント範囲を解析
    const docMatch = processedBody.match(/<document{(\d+)(?:-(\d+))?}>/);
    if (docMatch) {
      result.documentRange = {
        start: parseInt(docMatch[1]),
        end: docMatch[2] ? parseInt(docMatch[2]) : parseInt(docMatch[1])
      };
      processedBody = processedBody.replace(docMatch[0], '');
    }

    // 検索モードを解析
    if (processedBody.includes('<完全一致>')) {
      result.searchMode = 'exact';
      processedBody = processedBody.replace('<完全一致>', '');
    } else if (processedBody.includes('<半完全一致>')) {
      result.searchMode = 'semi-exact';
      const rangeMatch = processedBody.match(/<{(\d+)?-?(\d+)?}半完全一致{(\d+)?-?(\d+)?}>/);
      if (rangeMatch) {
        result.prefixRange = { min: rangeMatch[1] ? parseInt(rangeMatch[1]) : 0, max: rangeMatch[2] ? parseInt(rangeMatch[2]) : Infinity };
        result.suffixRange = { min: rangeMatch[3] ? parseInt(rangeMatch[3]) : 0, max: rangeMatch[4] ? parseInt(rangeMatch[4]) : Infinity };
        processedBody = processedBody.replace(rangeMatch[0], '');
      } else {
        processedBody = processedBody.replace('<半完全一致>', '');
      }
    } else if (processedBody.includes('<部分一致>')) {
      result.searchMode = 'partial';
      processedBody = processedBody.replace('<部分一致>', '');
    }
  
    // ifage/ifsage条件を抽出
    let ifageMatch;
    while ((ifageMatch = processedBody.match(/<ifage>\[([^\]]+)\]/))) {
      result.ifageTerms.push(ifageMatch[1]);
      processedBody = processedBody.replace(ifageMatch[0], '');
    }
  
    let ifsageMatch;
    while ((ifsageMatch = processedBody.match(/<ifsage>\[([^\]]+)\]/))) {
      result.ifsageTerms.push(ifsageMatch[1]);
      processedBody = processedBody.replace(ifsageMatch[0], '');
    }
  
    // メインの検索式を解析
    result.expression = parseExpression(processedBody);
  
    return result;
  }

  // 範囲文字列を解析
  function parseRange(rangeStr) {
    const cleanStr = rangeStr.replace(/[{}]/g, '');
    
    if (cleanStr === '*') {
      return { min: 0, max: Infinity };
    }
    
    // ^で区切られた複数条件
    if (cleanStr.includes('^')) {
      const parts = cleanStr.split('^');
      const ranges = parts.map(p => parseSingleRange(p));
      return { alternatives: ranges };
    }
    
    return parseSingleRange(cleanStr);
  }

  // 単一の範囲を解析
  function parseSingleRange(str) {
    if (str.match(/^(\d+)-(\d+)$/)) {
      const match = str.match(/^(\d+)-(\d+)$/);
      return { min: parseInt(match[1]), max: parseInt(match[2]) };
    } else if (str.match(/^(\d+)-$/)) {
      return { min: parseInt(str.match(/^(\d+)-$/)[1]), max: Infinity };
    } else if (str.match(/^-(\d+)$/)) {
      return { min: 0, max: parseInt(str.match(/^-(\d+)$/)[1]) };
    } else if (str.match(/^\d+$/)) {
      const val = parseInt(str);
      return { min: val, max: val };
    }
    return { min: 0, max: Infinity };
  }

  // 式を解析する再帰関数
  function parseExpression(expr) {
    // 最外部の[]を取り除く
    expr = expr.trim();
    if (expr.startsWith('[') && expr.endsWith(']')) {
      expr = expr.substring(1, expr.length - 1);
    }
    
    // {[...]<operator>[...]}形式の場合
    if (expr.startsWith('{[') || expr.includes('<')) {
      return parseComplexExpression(expr);
    }
    
    // 単純なキーワードの場合
    return { type: 'keyword', value: expr };
  }

  // 複雑な式を解析
  function parseComplexExpression(expr) {
    // NOT演算子の処理
    const notMatch = expr.match(/<not>\[([^\]]+)\]/);
    if (notMatch) {
      const remainingExpr = expr.replace(notMatch[0], '').trim();
      const mainExpr = remainingExpr ? parseExpression(remainingExpr) : null;
      return {
        type: 'not',
        expression: { type: 'keyword', value: notMatch[1] },
        mainExpression: mainExpr
      };
    }
    
    // 演算子を探す
    const operators = [
      { pattern: /<and{order}{connect{space{}}}>/g, type: 'and_order_connect_space' },
      { pattern: /<and{order}{connect{-(\d+)}}>/g, type: 'and_order_connect_limit' },
      { pattern: /<and{order}{connect}>/g, type: 'and_order_connect' },
      { pattern: /<and{connect{space{}}}>/g, type: 'and_connect_space' },
      { pattern: /<and{connect{-(\d+)}}>/g, type: 'and_connect_limit' },
      { pattern: /<and{connect}>/g, type: 'and_connect' },
      { pattern: /<and{order}>/g, type: 'and_order' },
      { pattern: /<and>/g, type: 'and' },
      { pattern: /<or>/g, type: 'or' }
    ];
    
    for (const op of operators) {
      const parts = splitByOperator(expr, op.pattern);
      if (parts.length > 1) {
        const limit = op.type.includes('limit') ? extractLimit(expr, op.pattern) : null;
        return {
          type: op.type,
          limit: limit,
          left: parseExpression(parts[0]),
          right: parseExpression(parts.slice(1).join(op.pattern.source.replace(/[\\^$.*+?()[\]{}|]/g, '')))
        };
      }
    }
    
    // 括弧を外す
    if (expr.startsWith('{[') && expr.includes(']}')) {
      const endIdx = findMatchingBracket(expr, 2);
      if (endIdx > 0) {
        const inner = expr.substring(2, endIdx);
        const remaining = expr.substring(endIdx + 2);
        if (remaining) {
          return parseExpression('{[' + inner + ']}' + remaining);
        }
        return parseExpression(inner);
      }
    }
    
    if (expr.startsWith('[') && expr.endsWith(']')) {
      return parseExpression(expr.substring(1, expr.length - 1));
    }
    
    return { type: 'keyword', value: expr };
  }

  // 演算子で式を分割
  function splitByOperator(expr, pattern) {
    const matches = [];
    const regex = new RegExp(pattern);
    let match;
    let lastIndex = 0;
    const parts = [];
    
    // パターンをグローバルに変換
    const globalPattern = new RegExp(pattern.source, 'g');
    
    while ((match = globalPattern.exec(expr)) !== null) {
      // 括弧の深さをチェック
      const beforeOp = expr.substring(0, match.index);
      if (isBalanced(beforeOp)) {
        parts.push(expr.substring(lastIndex, match.index));
        lastIndex = match.index + match[0].length;
      }
    }
    
    if (lastIndex < expr.length) {
      parts.push(expr.substring(lastIndex));
    }
    
    return parts.length > 1 ? parts : [expr];
  }

  // 括弧のバランスをチェック
  function isBalanced(str) {
    let depth = 0;
    for (const char of str) {
      if (char === '[' || char === '{') depth++;
      if (char === ']' || char === '}') depth--;
    }
    return depth === 0;
  }

  // 対応する括弧を見つける
  function findMatchingBracket(str, startIdx) {
    let depth = 1;
    for (let i = startIdx; i < str.length; i++) {
      if (str[i] === '[' || str[i] === '{') depth++;
      if (str[i] === ']' || str[i] === '}') {
        depth--;
        if (depth === 0) return i;
      }
    }
    return -1;
  }

  // 制限値を抽出
  function extractLimit(expr, pattern) {
    const match = expr.match(new RegExp(pattern.source.replace(/g$/, '')));
    if (match && match[1]) {
      return parseInt(match[1]);
    }
    return null;
  }

  // レスの本文を抽出（完全一致・半完全一致用）
  function extractPostBody(content) {
    // 最後の「 <>」を削除
    let cleanContent = content.replace(/ <>$/, '');
    
    // <>で分割
    const parts = cleanContent.split('<>');
    
    // 最後から2番目の要素を取得（本文）
    if (parts.length >= 2) {
      // 最後の要素がURLやIDの場合があるので、本文となる部分を探す
      for (let i = parts.length - 1; i >= 0; i--) {
        const part = parts[i].trim();
        // URLやID、数字のみでない部分を本文とする
        if (part && !part.startsWith('http') && !part.match(/^\d+$/)) {
          return part;
        }
      }
    }
    
    return cleanContent;
  }

  // 高度な検索を実行する関数
  function executeAdvancedSearch(parsedQuery) {
    // 全表示の場合
    if (parsedQuery.type === 'all') {
      const results = [];
      allDocumentThreads.forEach((threads, docId) => {
        threads.forEach(thread => {
          results.push({
            ...thread,
            matchedPosts: thread.posts,
            documentName: docId
          });
        });
      });
      return results;
    }
    
    // ドキュメント範囲でフィルタリング
    let targetDocuments = allDocumentThreads;
    if (parsedQuery.documentRange) {
      targetDocuments = new Map();
      for (let i = parsedQuery.documentRange.start; i <= parsedQuery.documentRange.end; i++) {
        const docId = String(i);
        if (allDocumentThreads.has(docId)) {
          targetDocuments.set(docId, allDocumentThreads.get(docId));
        }
      }
    }
    
    const results = [];
    
    // 各ドキュメントのスレッドを検索
    targetDocuments.forEach((threads, docId) => {
      threads.forEach(thread => {
        const matchedPosts = [];
        
        thread.posts.forEach(post => {
          let searchTarget = post.content;
          
          // 完全一致・半完全一致の場合は本文のみを抽出
          if (parsedQuery.searchMode === 'exact' || parsedQuery.searchMode === 'semi-exact') {
            searchTarget = extractPostBody(post.content);
          }
          
          const matchResult = evaluateExpression(
            parsedQuery.expression, 
            searchTarget, 
            post,
            parsedQuery.searchMode,
            parsedQuery.prefixRange,
            parsedQuery.suffixRange
          );
          
          if (matchResult) {
            matchedPosts.push(post);
          }
        });
        
        if (matchedPosts.length > 0) {
          // 優先度スコアを計算
          let priorityScore = 0;
          
          // ifage条件のチェック
          parsedQuery.ifageTerms.forEach(term => {
            if (thread.posts.some(p => {
              const target = parsedQuery.searchMode === 'partial' ? 
                `${p.content} ${p.author} ${p.userId}` : extractPostBody(p.content);
              return target.toLowerCase().includes(term.toLowerCase());
            })) {
              priorityScore += 100;
            }
          });
          
          // ifsage条件のチェック
          parsedQuery.ifsageTerms.forEach(term => {
            if (thread.posts.some(p => {
              const target = parsedQuery.searchMode === 'partial' ? 
                `${p.content} ${p.author} ${p.userId}` : extractPostBody(p.content);
              return target.toLowerCase().includes(term.toLowerCase());
            })) {
              priorityScore -= 100;
            }
          });
          
          results.push({
            ...thread,
            matchedPosts,
            documentName: docId,
            priorityScore
          });
        }
      });
    });
    
    // 優先度でソート
    results.sort((a, b) => b.priorityScore - a.priorityScore);
    
    return results;
  }

  // 式を評価
  function evaluateExpression(expr, content, post, searchMode, prefixRange, suffixRange) {
    if (!expr) return false;
    
    const contentLower = content.toLowerCase();
    
    switch (expr.type) {
      case 'keyword':
        return evaluateKeyword(expr.value, contentLower, post, searchMode, prefixRange, suffixRange);
      
      case 'and':
        return evaluateExpression(expr.left, content, post, searchMode, prefixRange, suffixRange) &&
               evaluateExpression(expr.right, content, post, searchMode, prefixRange, suffixRange);
      
      case 'or':
        return evaluateExpression(expr.left, content, post, searchMode, prefixRange, suffixRange) ||
               evaluateExpression(expr.right, content, post, searchMode, prefixRange, suffixRange);
      
      case 'not':
        const mainResult = expr.mainExpression ? 
          evaluateExpression(expr.mainExpression, content, post, searchMode, prefixRange, suffixRange) : true;
        const notResult = evaluateExpression(expr.expression, content, post, searchMode, prefixRange, suffixRange);
        return mainResult && !notResult;
      
      case 'and_order':
        const leftMatch = findKeywordPosition(expr.left, contentLower);
        const rightMatch = findKeywordPosition(expr.right, contentLower);
        return leftMatch !== -1 && rightMatch !== -1 && leftMatch < rightMatch;
      
      case 'and_connect':
        return evaluateConnect(expr.left, expr.right, contentLower, 0);
      
      case 'and_connect_limit':
        return evaluateConnect(expr.left, expr.right, contentLower, expr.limit);
      
      case 'and_connect_space':
        return evaluateConnectSpace(expr.left, expr.right, contentLower);
      
      case 'and_order_connect':
        return evaluateOrderConnect(expr.left, expr.right, contentLower, 0);
      
      case 'and_order_connect_limit':
        return evaluateOrderConnect(expr.left, expr.right, contentLower, expr.limit);
      
      case 'and_order_connect_space':
        return evaluateOrderConnectSpace(expr.left, expr.right, contentLower);
      
      default:
        return false;
    }
  }

  // キーワードを評価
  function evaluateKeyword(keyword, content, post, searchMode, prefixRange, suffixRange) {
    const keywordLower = keyword.toLowerCase();
    
    if (searchMode === 'exact') {
      return content === keywordLower;
    } else if (searchMode === 'semi-exact') {
      const index = content.indexOf(keywordLower);
      if (index === -1) return false;
      
      const prefixLen = index;
      const suffixLen = content.length - index - keywordLower.length;
      
      return checkRange(prefixLen, prefixRange) && checkRange(suffixLen, suffixRange);
    } else {
      // 部分一致の場合は本文、著者名、IDすべてを検索
      return content.includes(keywordLower) ||
             post.author.toLowerCase().includes(keywordLower) ||
             post.userId.toLowerCase().includes(keywordLower.replace(/\s/g, ''));
    }
  }

  // 範囲をチェック
  function checkRange(value, range) {
    if (!range) return true;
    
    if (range.alternatives) {
      return range.alternatives.some(r => value >= r.min && value <= r.max);
    }
    
    return value >= range.min && value <= range.max;
  }

  // キーワードの位置を検索
  function findKeywordPosition(expr, content) {
    if (expr.type === 'keyword') {
      return content.indexOf(expr.value.toLowerCase());
    }
    return -1;
  }

  // 接続条件を評価
  function evaluateConnect(leftExpr, rightExpr, content, maxGap) {
    const leftKeyword = getKeywordValue(leftExpr).toLowerCase();
    const rightKeyword = getKeywordValue(rightExpr).toLowerCase();
    
    // 左側のORまたは通常のキーワード評価
    const leftPositions = findAllPositions(content, leftKeyword);
    const rightPositions = findAllPositions(content, rightKeyword);
    
    for (const leftPos of leftPositions) {
      for (const rightPos of rightPositions) {
        if (rightPos > leftPos) {
          const gap = rightPos - (leftPos + leftKeyword.length);
          if (gap >= 0 && gap <= maxGap) {
            return true;
          }
        }
      }
    }
    
    // rightExprがOR条件の場合の特別処理
    if (rightExpr.type === 'or') {
      const altRightKeyword = getKeywordValue(rightExpr.right).toLowerCase();
      const altRightPositions = findAllPositions(content, altRightKeyword);
      
      for (const leftPos of leftPositions) {
        for (const rightPos of altRightPositions) {
          if (rightPos > leftPos) {
            const gap = rightPos - (leftPos + leftKeyword.length);
            if (gap >= 0 && gap <= maxGap) {
              return true;
            }
          }
        }
      }
    }
    
    return false;
  }

  // スペース接続を評価
  function evaluateConnectSpace(leftExpr, rightExpr, content) {
    const leftKeyword = getKeywordValue(leftExpr).toLowerCase();
    const rightKeyword = getKeywordValue(rightExpr).toLowerCase();
    
    // スペースで接続されているかチェック
    const spacePattern = new RegExp(
      escapeRegex(leftKeyword) + '[ 　]+' + escapeRegex(rightKeyword),
      'i'
    );
    
    return spacePattern.test(content);
  }

  // 順序付き接続を評価
  function evaluateOrderConnect(leftExpr, rightExpr, content, maxGap) {
    return evaluateConnect(leftExpr, rightExpr, content, maxGap);
  }

  // 順序付きスペース接続を評価
  function evaluateOrderConnectSpace(leftExpr, rightExpr, content) {
    return evaluateConnectSpace(leftExpr, rightExpr, content);
  }

  // キーワード値を取得
  function getKeywordValue(expr) {
    if (expr.type === 'keyword') {
      return expr.value;
    }
    // OR条件の場合は左側を返す
    if (expr.type === 'or') {
      return getKeywordValue(expr.left);
    }
    return '';
  }

  // 文字列内のすべての位置を検索
  function findAllPositions(str, keyword) {
    const positions = [];
    let index = str.indexOf(keyword);
    while (index !== -1) {
      positions.push(index);
      index = str.indexOf(keyword, index + 1);
    }
    return positions;
  }

  // 正規表現エスケープ
  function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  
  async function searchPosts() {
    const keyword = document.getElementById('searchInput').value.trim();
    if (!keyword) {
      clearSearch();
      return;
    }

    const fetchSuccess = await fetchRequiredDocuments();
    if (!fetchSuccess) return;

    if (allDocumentThreads.size === 0) {
      updateInfoPanel('<span style="color: #c0392b;">検索対象のドキュメントがありません。</span>');
      return;
    }

    document.getElementById('results').innerHTML = '<div class="loading">検索中...</div>';
    
    setTimeout(() => {
      let searchResults = [];
      const searchType = document.querySelector('input[name="searchType"]:checked').value;
      
      // 高度な検索の場合
      const advancedQuery = parseAdvancedSearch(keyword);
      if (advancedQuery) {
        searchResults = executeAdvancedSearch(advancedQuery);
      } else {
        // 通常の検索
        allDocumentThreads.forEach((threads, docId) => {
          searchResults.push(...searchInThreads(threads, keyword, docId, searchType));
        });
      }

      currentSearchResults = searchResults;
      const sortOrder = document.querySelector('input[name="sortOrder"]:checked').value;
      const sortedResults = sortSearchResults(searchResults, sortOrder);
      renderSearchResults(sortedResults, keyword);
      updateUrlParams(keyword, searchType);
    }, 100);
  }

  function applySorting() {
    if (currentSearchResults.length === 0) return;
    const keyword = document.getElementById('searchInput').value.trim();
    const sortOrder = document.querySelector('input[name="sortOrder"]:checked').value;
    const sortedResults = sortSearchResults(currentSearchResults, sortOrder);
    renderSearchResults(sortedResults, keyword);
  }
  
  function clearSearch() {
    document.getElementById('searchInput').value = '';
    document.getElementById('results').innerHTML = '<p>検索ボックスにキーワードを入力して検索してください。</p>';
    document.getElementById('searchSummary').style.display = 'none';
    document.getElementById('sortOptions').style.display = 'none';
    currentSearchResults = [];
    updateInfoPanel();
    updateUrlParams('', 'all');
  }

  function resetFetchState() {
    allDocuments = [];
    allDocumentThreads.clear();
    fetchedDocumentIds.clear();
    currentSearchResults = [];
    document.getElementById('results').innerHTML = '';
    document.getElementById('searchSummary').style.display = 'none';
    document.getElementById('sortOptions').style.display = 'none';
    renderDocumentsList();
    const infoDiv = document.getElementById('info');
    infoDiv.innerHTML = `キャッシュをクリアしました。次の検索時にデータを再取得します。<br>準備完了。全${totalDocumentCount}件のドキュメントから検索できます。`;
  }

  function updateUrlParams(keyword, searchType = null) {
    const url = new URL(window.location);
    
    // 検索キーワードの設定
    if (keyword) {
      url.searchParams.set('search', keyword);
    } else {
      url.searchParams.delete('search');
    }
    
    // 検索範囲の設定
    if (searchType && searchType !== 'all') {
      if (searchType === 'title') {
        url.searchParams.set('type', 'suretai');
      } else if (searchType === 'body') {
        url.searchParams.set('type', 'honbun');
      }
    } else {
      url.searchParams.set('type', 'subete');
    }
    
    window.history.pushState({}, '', url);
  }

  function checkUrlParams() {
    const params = new URLSearchParams(window.location.search);
    const searchParam = params.get('search');
    const typeParam = params.get('type');
    
    // 検索範囲の設定
    if (typeParam) {
      if (typeParam === 'suretai') {
        document.querySelector('input[name="searchType"][value="title"]').checked = true;
      } else if (typeParam === 'honbun') {
        document.querySelector('input[name="searchType"][value="body"]').checked = true;
      } else {
        document.querySelector('input[name="searchType"][value="all"]').checked = true;
      }
    }
    
    // 検索実行
    if (searchParam) {
      document.getElementById('searchInput').value = searchParam;
      searchPosts();
    }
  }

  function shareUrl() {
    const shareButton = document.getElementById('shareBtn');
    const originalText = shareButton.textContent;
    const keyword = document.getElementById('searchInput').value.trim();
    const searchType = document.querySelector('input[name="searchType"]:checked').value;
    
    const url = new URL(window.location);
    if (keyword) {
      url.searchParams.set('search', keyword);
      if (searchType === 'title') {
        url.searchParams.set('type', 'suretai');
      } else if (searchType === 'body') {
        url.searchParams.set('type', 'honbun');
      } else {
        url.searchParams.set('type', 'subete');
      }
    } else {
      url.searchParams.delete('search');
      url.searchParams.delete('type');
    }

    navigator.clipboard.writeText(url.toString()).then(() => {
      shareButton.textContent = 'コピー完了';
      setTimeout(() => { shareButton.textContent = originalText; }, 2000);
    }).catch(() => { 
      prompt('以下のURLをコピーしてください:', url.toString()); 
    });
  }
  
  // イベントリスナーの設定
  document.getElementById('searchBtn').addEventListener('click', searchPosts);
  document.getElementById('clearBtn').addEventListener('click', clearSearch);
  document.getElementById('docsBtn').addEventListener('click', toggleDocumentsList);
  document.getElementById('shareBtn').addEventListener('click', shareUrl);
  document.getElementById('helpBtn').addEventListener('click', toggleHelpPanel);
  
  document.getElementById('refreshBtn').addEventListener('click', () => {
    resetFetchState();
    if (document.getElementById('searchInput').value.trim()) {
      searchPosts();
    }
  });

  document.getElementById('fetchAllDocs').addEventListener('change', (e) => {
    document.getElementById('fetchCount').disabled = e.target.checked;
    resetFetchState();
    if (document.getElementById('searchInput').value.trim()) {
      searchPosts();
    }
  });
  
  document.getElementById('searchInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); searchPosts(); }
  });
  
  document.querySelectorAll('input[name="sortOrder"]').forEach(radio => {
    radio.addEventListener('change', applySorting);
  });

  document.querySelectorAll('input[name="searchType"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (document.getElementById('searchInput').value.trim()) {
        searchPosts();
      }
    });
  });

  window.addEventListener('popstate', checkUrlParams);
  
  // 初期化
  initializeSystem();
</script>
</body>
</html>
